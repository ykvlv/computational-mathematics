# Вычислительная математика. Лабораторная №2
### «Численное решение нелинейных уравнений и систем»


| Выполнил      | Группа | Преподаватель  |
| :------------ | ------ | -------------- |
| Яковлев Г. А. | P3213  | Малышева Т. А. |

## Цель работы
Изучить численные методы решения нелинейных уравнений и их систем,
найти корни заданного нелинейного уравнения, выполнить программную реализацию методов.

## Задания л/р
**Вариант 19** — метод хорд, простой итерации.

Уточнить корни нелинейного уравнения:
* Крайний правый — методом хорд
* Крайний левый — методом секущих
* Центральный — методом простой итерации

## Порядок выполнения л/р
* Отделить корни заданного нелинейного уравнения графически
* Определить интервалы изоляции корней
* Уточнить корни линейного уравнения с помощью различных методов

## Рабочие формулы используемых методов
Будут позже

## Листинг программы
Метод хорд:

```python
def chord_method(f: Callable[[float], float], a: float, b: float, accuracy: float,
                 max_iterations: int = 100) -> tuple[str, PrettyTable]:
    """ Метод хорд """
    fields = ['i', 'a', 'b', 'x', 'f(a)', 'f(b)', 'f(x)', '|a - b|']
    rows = []

    # Выбор начального приближения
    if f(a) * dd(f, a) > 0:
        x0 = a
    elif f(b) * dd(f, b) > 0:
        x0 = b
    else:
        # можно продумать условие
        x0 = a

    # инициализация
    i = 0
    x = (a * f(b) - b * f(a)) / (f(b) - f(a))
    rows.append([i, a, b, x, f(a), f(b), f(x), abs(a - b)])

    while abs(x - x0) > accuracy and i < max_iterations:
        i += 1

        if f(x) * f(a) < 0:
            b = x
        else:
            a = x

        x0, x = x, (a * f(b) - b * f(a)) / (f(b) - f(a))
        rows.append([i, a, b, x, f(a), f(b), f(x), abs(a - b)])

    make_graph(abs(x), abs(f(x)), f)

    return make_report(f, i, x, abs(x - x0)), make_table(fields, rows)
```


Метод секущих:

```python
def secant_method(f: Callable[[float], float], a: float, b: float, accuracy: float,
                  max_iterations: int = 100) -> tuple[str, PrettyTable]:
    """ Метод секущих """
    fields = ["i", "xi-1", "f(xi-1)", "xi", "f(xi)", "xi+1", "f(xi+1)", "|xi - xi+1|"]
    rows = []

    def cal(prev_x, now_x):
        return now_x - (now_x - prev_x) * f(now_x) / (f(now_x) - f(prev_x))

    # условие применимости метода Ньютона
    if f(a) * f(b) > 0:
        cprint(f"На концах отрезка [{a}, {b}] функция имеет одинаковые знаки.\n"
               f"На отрезке либо нет корней, либо их четное количество. Пожалуйста, уточните интервал.", "red")
        sys.exit(1)

    # выбор x0
    if f(a) * 2 * (3 * a - 5.84) > 0:
        x0 = a
    else:
        x0 = b

    # инициализация
    i = 0
    xi = x0 * accuracy * 2  # x1 выбирается рядом с x0 самостоятельно
    rows.append([i, x0, f(x0), xi, f(xi), cal(x0, xi), f(cal(x0, xi)), abs(xi - cal(x0, xi))])

    while abs(xi - x0) > accuracy and i < max_iterations:
        i += 1

        x0, xi = xi, cal(x0, xi)
        rows.append([i, x0, f(x0), xi, f(xi), cal(x0, xi), f(cal(x0, xi)), abs(xi - cal(x0, xi))])

    return make_report(f, i, xi, abs(xi - x0)), make_table(fields, rows)
```

Метод простых итераций:

```python
def simple_iteration_method(f: Callable[[float], float], approximation: float, accuracy: float,
                            max_iterations: int = 100) -> tuple[str, PrettyTable]:
    """ Метод простых итераций """

    def calculate_answer(func: Callable[[float], float]) -> tuple[str, PrettyTable]:
        fields = ['i', 'xi', 'f(x)', 'xi+1', 'φ(xi)', '|xi - xi+1|']
        rows = []

        # инициализация
        i = 0
        x0 = approximation
        x = func(x0)
        rows.append([i, x0, f(x0), x, func(x), abs(x - x0)])

        while abs(f(x)) > accuracy and i < max_iterations:
            i += 1

            x0, x = x, func(x0)
            rows.append([i, x0, f(x0), x, func(x), abs(x - x0)])

        return make_report(func, i, x, abs(f(x))), make_table(fields, rows)

    # подставим в производную функцию значение начального приближения
    f_approximation = d(f, approximation)
    lmb = -1 / f_approximation
    q = 1

    # сходится ли метод простой итерации
    if abs(3 * lmb * approximation ** 2 - 5.84 * lmb * approximation + q + 1.435 * lmb) < q and (
            approximation > 0 or approximation < -1):
        # достаточное условие сходимости выполнено и начальное приближение не лежит в интервале от -1 до 0
        return calculate_answer(lambda x: x + lmb * f(x))
    else:
        fi1 = (- 5.84 * approximation + 1.435) / 3 / (
                    (- 2.92 * approximation ** 2 + 1.435 * approximation + 0.791) ** 2) ** (1 / 3)
        if abs(fi1) < 1:
            return calculate_answer(lambda x: - 2.92 * x ** 2 + 1.435 * x + 0.791)
        else:
            cprint("Начальное приближение неверно, не выполняется достаточное условие сходимости метода.", "red")
            sys.exit(1)
```

## Примеры и результаты
Ввод из консоли:

```java
ykvlv@MacBook lab2 % python3 main.py
Решение уравнения x³ - 2.92x² + 1.435x + 0.791. Доступные методы:
2	Метод хорд
4	Метод секущих
5	Метод простой итерации
Введите номер метода: 2
Введите левую границу интервала: 1ю5
Требуется десятичное число. could not convert string to float: '1ю5'
Введите левую границу интервала: 1.5
Введите правую границу интервала: 2.5
Введите погрешность вычисления: 0.001
Выполнено решение уравнения x³ - 2.92x² + 1.435x + 0.791.
Х = 2.0099448082513147
Количество итераций i = 10
Критерий окончания итерационного процесса = 0.0007037468028547877
f(2.0099448082513147) = -0.0012412684148931374

Таблица итераций:
 i      a        b        x       f(a)      f(b)     f(x)    |a - b| 
 0   1.50000  2.50000  1.62544  -0.25150  1.75350  -0.29679  1.00000 
 1   1.62544  2.50000  1.75203  -0.29679  1.75350  -0.28005  0.87456 
 2   1.75203  2.50000  1.85504  -0.28005  1.75350  -0.21173  0.74797 
 3   1.85504  2.50000  1.92453  -0.21173  1.75350  -0.13434  0.64496 
 4   1.92453  2.50000  1.96548  -0.13434  1.75350  -0.07596  0.57547 
 5   1.96548  2.50000  1.98767  -0.07596  1.75350  -0.04017  0.53452 
 6   1.98767  2.50000  1.99914  -0.04017  1.75350  -0.02050  0.51233 
 7   1.99914  2.50000  2.00493  -0.02050  1.75350  -0.01027  0.50086 
 8   2.00493  2.50000  2.00781  -0.01027  1.75350  -0.00510  0.49507 
 9   2.00781  2.50000  2.00924  -0.00510  1.75350  -0.00252  0.49219 
 10  2.00924  2.50000  2.00994  -0.00252  1.75350  -0.00124  0.49076 
```

Запись в файл:

```java
ykvlv@MacBook lab2 % python3 main.py --out okgoogle
Решение уравнения x³ - 2.92x² + 1.435x + 0.791. Доступные методы:
2	Метод хорд
4	Метод секущих
5	Метод простой итерации
Введите номер метода: 4
Введите левую границу интервала: 2
Введите правую границу интервала: 1
Правая граница меньше левой. ъъъ ок я поправлю...
Введите погрешность вычисления: 0.001
Файл okgoogle записан успешно!
```

Чтение из файла:

```java
ykvlv@MacBook lab2 % python3 main.py --in tests/test3 --out okgoogle
Файл okgoogle записан успешно!
```

## Выводы

При помощи вычислительных устройств научился решать нелинейные уравнения различными методами (секущих, простых итераций, половинного деления...), которые собственноручно вычислял бы бесконечно долго.
