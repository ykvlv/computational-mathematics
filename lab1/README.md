# Вычислительная математика. Лабораторная №1
### «Решение системы линейных алгебраических уравнений СЛАУ»


| Выполнил      | Группа | Преподаватель  |
|---------------|--------|----------------|
| Яковлев Г. А. | P3213  | Малышева Т. А. |

## Цель работы
Научиться решать СЛАУ при помощи численных методов, написать программу, которая будет находить решение матрицы.

## Задания л/р
**Вариант 22** — метод Гаусса.

В работе должно присутствовать:

* Вычисление определителя
* Вывод треугольной матрицы (включая преобразованный столбец *В*)
* Вывод вектора неизвестных: *x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub>*
* Вывод вектора невязок: *r<sub>1</sub>, r<sub>2</sub>, …, r<sub>n</sub>*

## Описание метода
**Прямой ход** метода Гаусса состоит в последовательном исключении неизвестных из уравнений системы. Сначала с помощью первого уравнения исключается *x<sub>1</sub>* из всех последующих уравнений системы. Затем с помощью второго уравнения исключается *x<sub>2</sub>* из третьего и всех последующих уравнений и т. д. Этот процесс продолжается до тех пор, пока в левой части последнего (*n*-го) уравнения не останется лишь один член с неизвестным *x<sub>n</sub>*, т. е. матрица системы будет приведена к треугольному виду.

**Обратный ход** метода Гаусса состоит в последовательном вычислении искомых неизвестных: решая последнее уравнение, находим единственное в этом уравнении неизвестное *x<sub>n</sub>*. Далее, используя это значение, из предыдущего уравнения вычисляем *x<sub>n</sub>−1* и т. д. Последним найдем *x<sub>1</sub>* из первого уравнения.
Метод имеет много различных вычислительных схем, но в каждой из них основным требованием является *det A ≠ 0*.

## Листинг программы
Сначала, прямым ходом, преобразуем матрицу в треугольную:

```python
def make_triangle(a, b):
    n = len(a)
    for i in range(0, n - 1):
	
        if a[i][i] == 0:
            permute_equation(i, a, b)
	
        for k in range(i + 1, n):
            c = a[k][i] / a[i][i]
	
            for j in range(i, n):
                a[k][j] -= c * a[i][j]
            a[k][i] = 0
	
            b[k] -= c * b[i]
```

Затем, обратным ходом, найдем корни:

```python
def calc_answer_by_reverse(a, b):
    n = len(a)
    x = [0 for _ in range(n)]

    for i in range(n - 1, -1, -1):
        s = 0
        if a[i][i] == 0:
            its_error(a, b)

        for j in range(i + 1, n):
            s += a[i][j] * x[j]

        x[i] = (b[i] - s) / a[i][i]

    return x
```

## Примеры и результаты
Чтение из файла:

```java
ykvlv@MacBook lab1 % python3 main.py file tests/test1
Ваша матрица:
  x0   x1   x2   x3   c  
 3.0  2.0  9.0  4.0  1.0 
 2.0  6.0  4.0  2.0  1.0 
 4.0  8.0  5.0  4.0  1.0 
 9.0  3.0  6.0  3.0  1.0 

Треугольная матрица получилась такая:
  x0          x1                  x2                   x3                   c          
 3.0         2.0                 9.0                  4.0                  1.0         
  0   4.666666666666667          -2.0         -0.6666666666666665  0.33333333333333337 
  0           0          -4.7142857142857135  -0.5714285714285712  -0.7142857142857143 
  0           0                   0            -6.727272727272728   1.5909090909090913 

Корни получились:
          x0                   x1                  x2                   x3         
 0.03153153153153151  0.11486486486486487  0.1801801801801802  -0.2364864864864865 

Невязки получились:
  x0   x1   x2            x3           
 0.0  0.0  0.0  3.3306690738754696e-16 

```

Ввод из консоли:

```java
ykvlv@MacBook lab1 % python3 main.py
Введите матрицу в формате:
В первой строке целое число n (1 <= n <= 20) — размерность матрицы.
Далее следует n строк, в каждой n чисел — элемены матрицы.
Последняя строка — коэффициенты матрицы.
2
1 2
0 0
2 3
Ваша матрица:
  x0   x1   c  
 1.0  2.0  2.0 
 0.0  0.0  3.0 

Треугольная матрица получилась такая:
  x0   x1   c  
 1.0  2.0  2.0 
  0   0.0  3.0 

Ну короче решений нет. Нолик мешает
```

## Выводы
При помощи вычислительных устройств научился приближенно вычислять СЛАУ различными способами (методом Гаусса), которые собственноручно вычислял бы бесконечно долго.
